@startuml Activity Diagram 1: UI Manifest Extraction
!theme plain

title แผนภาพกิจกรรม 1: การวิเคราะห์และสกัดสมรรถนะส่วนติดต่อผู้ใช้\n(Extract UI Manifest - Step 1)

|นักทดสอบ|
|เครื่องมือสกัด UI Manifest|

|นักทดสอบ|
start
:เรียกใช้เครื่องมือ\nextract_ui_manifest.dart;
note right
  คำสั่ง:
  • dart run tools/script_v2/extract_ui_manifest.dart <file>
  • dart run tools/script_v2/extract_ui_manifest.dart (scan all)
end note

if (ระบุไฟล์ UI?) then (ระบุไฟล์)
  :ป้อนพาธไฟล์ UI\n(lib/demos/xxx_page.dart);
else (ไม่ระบุ)
  :ให้ระบบสแกนทั้งโฟลเดอร์\n(lib/**/*_page.dart);
endif

|เครื่องมือสกัด UI Manifest|
:รับรายการไฟล์ที่จะประมวลผล;

repeat
  :เลือกไฟล์ถัดไป;

  :ตรวจสอบไฟล์มีอยู่จริง\n(File.existsSync);

  if (ไฟล์มีอยู่?) then (พบไฟล์)
    :อ่าน source code\nจากไฟล์ .dart;
    note right
      File.readAsStringSync()
      อ่านเนื้อหาทั้งหมดของไฟล์
    end note

    :ลบ comments ออก\n(// และ /* */);
    note right
      ป้องกัน false positives
      จาก widgets ใน comments
    end note

    partition "วิเคราะห์ Metadata" {
      :สกัด String Constants\n(const KEY = 'value');

      :ค้นหา Page Class\n(extends StatefulWidget);
      note right
        class XxxPage extends StatefulWidget
      end note

      :ค้นหา Cubit Type\n(BlocBuilder<XxxCubit, ...>);

      :ค้นหา State Type\n(BlocBuilder<..., XxxState>);

      :ค้นหาพาธไฟล์ Cubit/State\n(จาก import statements);
    }

    partition "สแกนและสกัด Widgets" {
      :สแกนหา Widget patterns\nที่รองรับ;
      note right
        Widget types:
        • TextField, TextFormField
        • ElevatedButton, TextButton, IconButton
        • DropdownButton, Radio, Checkbox
        • Switch, Slider, ListTile
        • Text, Visibility, SnackBar
      end note

      repeat
        :พบ Widget constructor;

        :ใช้ Regex match parentheses\nสกัด arguments;

        :สกัดข้อมูล Widget:
        • widgetType
        • key (Key/ValueKey/ObjectKey)
        • sourceOrder;

        if (Widget type คือ?) then (TextField/TextFormField)
          :สกัด TextField metadata:
          • keyboardType
          • obscureText
          • maxLength
          • inputFormatters
          • validatorRules;

        elseif (DropdownButton) then
          :สกัด Dropdown options:
          • value
          • text (label);

        elseif (Radio) then
          :สกัด Radio metadata:
          • value
          • groupValue;

        elseif (FormField with Radio) then
          :สกัด Radio options\nภายใน FormField builder;

        elseif (Text with state binding) then
          :สกัด displayBinding\n(state.fieldName);

        else (Widget อื่นๆ)
          :สกัด metadata พื้นฐาน;
        endif

        :ตรวจสอบ onTap callback;

        if (มี onTap ที่เรียก Picker?) then (มี)
          :สกัด Picker metadata:
          • DatePicker: firstDate, lastDate, initialDate
          • TimePicker: initialTime;

          :เชื่อมโยง pickerMetadata\nกับ widget;
        endif

        :เพิ่ม widget ลง list;

      repeat while (ยังมี widgets?) is (มี)
      -> ไม่มีแล้ว;
    }

    :กรองเฉพาะ widgets ที่มี key;
    note right
      widgets ที่ไม่มี key จะถูกละทิ้ง
      เพราะไม่สามารถทดสอบได้
    end note

    :ลบ duplicate keys\n(เก็บ first occurrence);

    :เรียงลำดับ widgets:
    1. ตาม SEQUENCE prefix (1_, 2_, 3_...)
    2. ตาม sourceOrder;
    note right
      Pattern: {SEQUENCE}_*_{WIDGET}
      เช่น "1_customer_firstname_textfield"
    end note

    :ลบ sourceOrder ออก\n(ใช้สำหรับ sorting เท่านั้น);

    :สร้าง JSON structure;
    note right
      {
        "source": {
          "file": "lib/...",
          "pageClass": "XxxPage",
          "cubitClass": "XxxCubit",
          "stateClass": "XxxState",
          "fileCubit": "lib/cubit/xxx_cubit.dart",
          "fileState": "lib/cubit/xxx_state.dart"
        },
        "widgets": [
          {
            "widgetType": "TextField",
            "key": "1_firstname_textfield",
            "meta": {
              "keyboardType": "text",
              "maxLength": 50,
              "inputFormatters": [...],
              "validatorRules": [...]
            }
          },
          ...
        ]
      }
    end note

    :คำนวณ output path\nตาม subfolder structure;
    note right
      Input:  lib/demos/buttons_page.dart
      Output: output/manifest/demos/
              buttons_page.manifest.json
    end note

    :สร้าง output directory\n(createSync recursive);

    :เขียนไฟล์ JSON\n(JsonEncoder.withIndent);

    |นักทดสอบ|
    :แสดงข้อความสำเร็จ\n"✓ Manifest written: <path>";

    |เครื่องมือสกัด UI Manifest|
  else (ไม่พบไฟล์)
    |นักทดสอบ|
    :แสดง Error\n"File not found: <path>";
    |เครื่องมือสกัด UI Manifest|
  endif

repeat while (ยังมีไฟล์?) is (มี)
-> ประมวลผลครบแล้ว;

|นักทดสอบ|
:ได้รับ Manifest Files\n(output/manifest/**/*.manifest.json);

stop

@enduml
