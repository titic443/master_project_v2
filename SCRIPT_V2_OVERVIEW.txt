tools/script_v2 - Test Generation Pipeline Overview
====================================================

OVERVIEW:
========
tools/script_v2 เป็น automated test generation pipeline ที่ประกอบด้วย 4 scripts หลัก
ทำงานแบบ sequential pipeline เพื่อสร้าง Flutter widget tests จาก UI source code

PIPELINE FLOW:
=============
1. Flutter UI Code (.dart)
   ↓
2. IR Generation (Intermediate Representation)
   ↓
3. Dataset Generation (Optional - for boundary testing)
   ↓
4. Test Plan Generation (with Pairwise optimization)
   ↓
5. Flutter Test Code Generation (.dart)


SCRIPT DETAILS:
===============

1. ir_action_lister.dart
------------------------
PURPOSE: Static analysis ของ Flutter UI code เพื่อสกัด widget information
COMMAND: dart run tools/script_v2/ir_action_lister.dart lib/demos/buttons_page.dart
INPUT:   lib/demos/*.page.dart (Flutter UI source files)
OUTPUT:  test_ir/actions/*.ir.json (Intermediate Representation)

FUNCTIONALITY:
- Scan Dart source code for UI widgets
- Extract widget information:
  * widgetType: TextFormField, Radio, DropdownButtonFormField, ElevatedButton, etc.
  * key: Widget keys for testing (e.g., 'buttons_textfield')
  * actions: Event handlers (onChanged, onPressed, onTap)
  * meta: Constraints and validation rules
    - maxLength, inputFormatters, validator messages
    - dropdown items, radio values, form validation rules
  * wrappers: BlocListener, BlocBuilder, BlocSelector detection
  * textLiteral: Static text content for assertions
- Strip comments และ process string constants
- Find Cubit types และ page routes
- Generate structured JSON representation

EXAMPLE OUTPUT:
{
  "source": {
    "file": "lib/demos/buttons_page.dart",
    "pageClass": "ButtonsDemo",
    "route": "/buttons"
  },
  "widgets": [
    {
      "widgetType": "TextFormField",
      "key": "buttons_textfield",
      "actions": [{"event": "onChanged", "calls": [{"target": "ButtonsCubit", "method": "onTextChanged"}]}],
      "meta": {
        "maxLength": 10,
        "inputFormatters": [{"type": "allow", "pattern": "[a-zA-Z0-9]"}],
        "validator": true,
        "validatorMessages": ["Required"]
      }
    }
  ]
}


2. datasets_from_ir.dart
-------------------------
PURPOSE: Generate test datasets for boundary value analysis
COMMAND: dart run tools/script_v2/datasets_from_ir.dart
INPUT:   test_ir/actions/*.ir.json
OUTPUT:  test_data/*.datasets.json

FUNCTIONALITY:
- Extract TextFormField constraints from IR
- Generate boundary test values:
  * Valid: min length, max length, nominal values
  * Invalid: empty, too long, invalid characters
- Use faker library for realistic test data
- Create comprehensive dataset variations:
  * Edge cases: "", "a", "1234567890" (for maxLength=10)
  * Invalid patterns: special characters ถ้า allow only alphanumeric
  * Boundary conditions: exactly at limits

EXAMPLE OUTPUT:
{
  "buttons_textfield": {
    "valid": ["a", "test123", "1234567890"],
    "invalid": ["", "toolongstring", "test@#$"]
  }
}


3. generate_test_data.dart
-------------------
PURPOSE: Generate comprehensive test plans with optional pairwise optimization
COMMAND: dart run tools/script_v2/generate_test_data.dart [--pairwise-merge] [--plan-summary]
INPUT:   test_ir/actions/*.ir.json, test_data/*.datasets.json (optional)
OUTPUT:  test_data/*.testdata.json

FUNCTIONALITY:
- Factor Detection:
  * TextFormFields → boundary values (min, min+1, nominal, max-1, max)
  * Radio Groups → all option combinations
  * Dropdowns → all available items
  * API Outcomes → success (200), client error (400), server error (500)

- Test Strategy Selection:
  FULL-FLOW (default):
  - Complete boundary testing
  - All widget interaction combinations
  - Comprehensive API scenario coverage
  - Generates ~240+ test cases for complex forms

  PAIRWISE (--pairwise-merge):
  - Dynamic factor detection
  - Optimal pairwise coverage algorithm
  - Excludes API factors (*_endapi_* pattern)
  - Reduces test cases by ~89% (6 factors → 26 cases)
  - Maintains 100% pair coverage

- Test Case Structure:
  * Each case: sequence of widget interactions
  * Factor combinations: scientific test design
  * API simulation: different response codes
  * Assertions: expected UI states และ navigation

EXAMPLE OUTPUT:
{
  "file": "lib/demos/buttons_page.dart",
  "pageClass": "ButtonsDemo",
  "strategy": "pairwise",
  "factors": {
    "TEXT1": ["min", "min+1", "nominal", "max-1", "max"],
    "RADIO2": [0, 1],
    "DROPDOWN": ["apple", "banana", "cherry"]
  },
  "cases": [
    {
      "name": "Test case 1: min TEXT1, approve RADIO2, apple DROPDOWN",
      "steps": [
        {"action": "enterText", "target": "buttons_textfield", "value": "a"},
        {"action": "tapRadio", "target": "buttons_approve_radio"},
        {"action": "selectDropdown", "target": "buttons_dropdown", "value": "apple"},
        {"action": "tap", "target": "buttons_endapi_button"}
      ],
      "expects": [
        {"target": "buttons_status_200", "exists": false},
        {"navigation": "_NextPage"}
      ]
    }
  ]
}


4. generate_test_script.dart
-------------------------
PURPOSE: Convert test plans to executable Flutter widget tests
COMMAND: dart run tools/script_v2/generate_test_script.dart
INPUT:   test_data/*.testdata.json
OUTPUT:  test/generated/*_flow_test.dart

FUNCTIONALITY:
- Generate testWidgets functions for each test case
- Create mock Cubit implementations:
  * Success scenarios: return ApiResponse(code: 200)
  * Error scenarios: throw ButtonsException(code: 400/500)
- Widget interaction code:
  * await tester.enterText(find.byKey(Key('...')), value)
  * await tester.tap(find.byKey(Key('...')))
  * await tester.pumpAndSettle()
- Assertion generation:
  * expect(find.byKey(Key('...')), findsOneWidget)
  * expect(find.text('success'), findsOneWidget)
  * await tester.pageBack() // navigation verification
- Import management: auto-detect และ import required packages
- Provider setup: BlocProvider wrapping for Cubit injection

EXAMPLE OUTPUT:
```dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:master_project/demos/buttons_page.dart';
import 'package:master_project/cubit/buttons_cubit.dart';

void main() {
  group('ButtonsDemo Flow Tests', () {
    testWidgets('Test case 1: min TEXT1, approve RADIO2, apple DROPDOWN', (tester) async {
      final cubit = MockButtonsCubit(shouldSucceed: true);
      
      await tester.pumpWidget(
        MaterialApp(
          home: BlocProvider<ButtonsCubit>(
            create: (_) => cubit,
            child: ButtonsDemo(),
          ),
        ),
      );
      
      await tester.enterText(find.byKey(Key('buttons_textfield')), 'a');
      await tester.tap(find.byKey(Key('buttons_approve_radio')));
      await tester.tap(find.byKey(Key('buttons_dropdown')));
      await tester.tap(find.text('Apple'));
      await tester.tap(find.byKey(Key('buttons_endapi_button')));
      await tester.pumpAndSettle();
      
      expect(find.byKey(Key('buttons_status_200')), findsOneWidget);
      expect(find.text('success'), findsOneWidget);
    });
  });
}
```


INTEGRATION WORKFLOW:
====================

Complete Test Generation Process:
---------------------------------
1. Write Flutter UI (lib/demos/buttons_page.dart)
2. dart run tools/ir_action_lister.dart lib/demos/buttons_page.dart
3. dart run tools/script_v2/datasets_from_ir.dart (optional)
4. dart run tools/script_v2/generate_test_data.dart --pairwise-merge
5. dart run tools/script_v2/generate_test_script.dart
6. flutter test test/generated/

Key Benefits:
------------
- AUTOMATED: No manual test writing
- COMPREHENSIVE: Boundary value analysis + combinations
- OPTIMIZED: Pairwise reduction (89% fewer tests, 100% coverage)
- DYNAMIC: Adapts to UI changes automatically
- SCIENTIFIC: Factor-based test design
- MAINTAINABLE: JSON-based configuration


CONFIGURATION OPTIONS:
=====================

Command Line Flags:
-------------------
--pairwise-merge: Enable pairwise optimization
--plan-summary: Show test plan statistics

Factor Exclusion Patterns:
--------------------------
*_endapi_*: API buttons (excluded from pairwise)
*_status_*: Status dialogs (assertion targets only)

Boundary Value Settings:
-----------------------
TextFormField boundaries: min, min+1, nominal, max-1, max
Radio Groups: all available options
Dropdowns: all menu items
API Responses: 200 (success), 400 (client error), 500 (server error)


ERROR HANDLING:
==============

Common Issues และ Solutions:
----------------------------
1. Missing IR files: Run ir_action_lister.dart first
2. Invalid widget keys: Check Key('...') definitions in UI
3. Cubit method mismatches: Verify BLoC method signatures
4. Test compilation errors: Check import paths และ package structure
5. Pairwise algorithm failures: Verify factor definitions และ constraints

Debug Commands:
--------------
dart run tools/script_v2/generate_test_data.dart --plan-summary  # Show statistics
flutter test test/generated/ -v                           # Verbose test output
flutter test test/generated/ --plain-name="Test case 1"   # Run specific test


PERFORMANCE METRICS:
===================

Typical Results (ButtonsDemo example):
-------------------------------------
- Factors detected: 6 (2 TextFields + 3 Radio Groups + 1 Dropdown)
- Full factorial: ~240 test cases
- Pairwise optimized: ~26 test cases (89% reduction)
- Pair coverage: 100% maintained
- Generation time: <5 seconds
- Test execution: ~30 seconds for full suite

Scale Comparison:
----------------
Complex forms (10+ factors):
- Full factorial: 10,000+ test cases (hours to run)
- Pairwise: 50-100 test cases (minutes to run)
- Coverage quality: Equivalent defect detection rate