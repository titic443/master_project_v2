@startuml test_verification_workflow
!theme plain
skinparam ActivityBackgroundColor #E8F5E9
skinparam ActivityBorderColor #388E3C
skinparam ActivityDiamondBackgroundColor #FFF9C4
skinparam NoteBorderColor #F57F17
skinparam NoteBackgroundColor #FFF9C4

title Test Verification Workflow\n(After Test Generation)

start

:Tests generated by\n**flutter_test_gen**;

note right
  Input:
  integration_test/customer_details_page_flow_test.dart
end note

partition "**Phase 1: Syntax & Build Check**" #LightBlue {
  :Run Dart analyzer;
  :Command: **flutter analyze**;

  if (Analysis passed?) then (yes)
    :✓ No syntax errors;
  else (no)
    :❌ Fix syntax errors in generated test;
    stop
  endif

  :Run build check;
  :Command: **flutter test --dry-run**;

  if (Build successful?) then (yes)
    :✓ Test file compiles;
  else (no)
    :❌ Fix import/dependency issues;
    stop
  endif
}

partition "**Phase 2: Execute Tests**" #LightGreen {
  :Run integration tests;
  :Command: **flutter test <test_file>**;

  note right
    Runs all test cases:
    - pairwise_valid_invalid_cases_1
    - pairwise_valid_invalid_cases_2
    - ...
    - valid_only_cases_1
    - ...
  end note

  if (All tests passed?) then (yes)
    :✓ Tests executed successfully;
  else (no)
    :Analyze failures;

    fork
      :Check UI implementation\n(missing widgets/keys);
    fork again
      :Check test assertions\n(incorrect expectations);
    fork again
      :Check Cubit logic\n(wrong state transitions);
    end fork

    :Fix issues and re-run;

    if (Fixed?) then (yes)
      :Continue;
    else (no)
      :❌ Tests still failing;
      stop
    endif
  endif
}

partition "**Phase 3: Coverage Analysis**" #LightYellow {
  :Run tests with coverage;
  :Command: **flutter test --coverage**;

  :Generate coverage report;
  :Command: **genhtml coverage/lcov.info**;

  note right
    Metrics to check:
    - Line coverage %
    - Branch coverage %
    - Function coverage %
  end note

  :Review coverage report;

  if (Coverage >= target?) then (≥ 80%)
    :✓ Good coverage;
  else (< 80%)
    :⚠ Low coverage detected;

    :Identify uncovered code:
    - Edge cases
    - Error handling paths
    - Conditional branches;

    :Add manual test cases\nfor uncovered scenarios;
  endif
}

partition "**Phase 4: Test Quality Review**" #LightCoral {
  :Manual review of test cases;

  :Check test structure;
  note right
    Verify:
    ✓ Clear test names
    ✓ Proper setup/teardown
    ✓ Isolated test cases
    ✓ No test interdependencies
  end note

  :Check assertions;
  note right
    Verify:
    ✓ Meaningful assertions
    ✓ Cover success & failure paths
    ✓ Check error messages
    ✓ Validate state transitions
  end note

  :Check test data;
  note right
    Verify:
    ✓ Realistic test values
    ✓ Edge cases covered
    ✓ Invalid data tested
    ✓ Boundary values included
  end note

  if (Quality acceptable?) then (yes)
    :✓ Tests meet quality standards;
  else (no)
    :Refactor or supplement tests;
    :Add missing test cases manually;
  endif
}

partition "**Phase 5: Mutation Testing (Optional)**" #Lavender {
  :Run mutation testing tool;
  note right
    Tools:
    - Not common in Flutter
    - Can manually inject bugs
  end note

  :Inject artificial bugs\ninto UI code;

  :Re-run tests;

  if (Tests caught the bugs?) then (yes)
    :✓ Tests are effective;
  else (no)
    :⚠ Tests are weak;
    :Improve test assertions;
  endif
}

partition "**Phase 6: Documentation & Report**" #LightCyan {
  :Generate test report;

  :Document:
  - Total test cases
  - Pass/Fail count
  - Coverage metrics
  - Execution time;

  :Create verification checklist;

  :Commit tests to repository;
}

:✓ Test verification complete;

stop

legend right
  |= Phase |= Focus |= Tools |
  | 1 | Syntax | flutter analyze |
  | 2 | Execution | flutter test |
  | 3 | Coverage | flutter test --coverage |
  | 4 | Quality | Manual review |
  | 5 | Effectiveness | Mutation testing |
  | 6 | Documentation | Test reports |
endlegend

@enduml
